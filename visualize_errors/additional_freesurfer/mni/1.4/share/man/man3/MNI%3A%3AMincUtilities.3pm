.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.14
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "MNI::MincUtilities 3"
.TH MNI::MincUtilities 3 "2001-07-11" "perl v5.8.5" "User Contributed Perl Documentation"
.SH "NAME"
MNI::MincUtilities \- various MINC file hacks using external utilities
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&   use MNI::MincUtilities qw(:range);
\&   $min = volume_min ($vol);
\&   $max = volume_max ($vol);
\&   ($min, $max) = volume_minmax ($vol);
.Ve
.PP
.Vb 3
\&   use MNI::MincUtilities qw(:threshold);
\&   $threshold = percent_threshold ($min, $max, $percent);
\&   $threshold = auto_threshold ($vol);
.Ve
.PP
.Vb 4
\&   use MNI::MincUtilities qw(:history);
\&   @history = get_history ($vol);
\&   put_history ($vol, @history);
\&   update_history ($vol [, $replace [, $history]]);
.Ve
.PP
.Vb 4
\&   use MNI::MincUtilities qw(:geometry);
\&   $cog = volume_cog ($vol);
\&   volume_params ($vol, \e@start, \e@step, \e@length, \e@dir_cosines, \e@dims);
\&   ($order, $permutation) = get_dimension_order ($vol);
.Ve
.PP
.Vb 4
\&   use MNI::MincUtilities qw(:args);
\&   @resample_args = compute_resample_args (\e@start, \e@extent, \e@step);
\&   @reshape_args = compute_reshape_args (\e@order, \e@oldstart, \e@oldstep,
\&                                         \e@start, \e@extent, \e@step);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fIMNI::MincUtilities\fR provides a number of miscellaneous utility routines
to query and/or compute various useful parameters of a \s-1MINC\s0 file and the
data in it, and to get/put/update its history.  The common thread is that
everything (well, almost everything) is done via external utilities, such
as \f(CW\*(C`mincinfo\*(C'\fR or \f(CW\*(C`volume_stats\*(C'\fR.  Note that some of these utilities are
distributed with the \s-1MINC\s0 package, so if you have the \s-1MINC\s0 library
installed you should have the utilities; other utilities are distributed
with other packages (such as \f(CW\*(C`volume_cog\*(C'\fR, included with the \s-1MNI\s0 AutoReg
package); and other utilities (such as \f(CW\*(C`volume_stats\*(C'\fR) may not be
available outside the \s-1MNI\s0.  Unfortunately, there's currently no way to know
which is which until you try to use them via a function in
\&\fIMNI::MincUtilities\fR and your program crashes.
.PP
Eventually, this module will (hopefully) be superseded by the \fI\s-1MNI::MINC\s0\fR
family of modules, but since those modules don't exist as of this writing,
\&\fIMNI::MincUtilities\fR is being provided as a stop-gap measure.  It is
intended that this will solve the problem of reliance on possibly
unavailable external programs.
.PP
The subroutines provided by \fIMNI::MincUtilities\fR fall into roughly five
groups:
.IP "* volume range" 4
.IX Item "volume range"
Query the volume min and max values (\f(CW\*(C`volume_min\*(C'\fR, \f(CW\*(C`volume_max\*(C'\fR,
\&\f(CW\*(C`volume_minmax\*(C'\fR).
.IP "* compute thresholds" 4
.IX Item "compute thresholds"
Compute either percentage or automatic threshold values
(\f(CW\*(C`percent_threshold\*(C'\fR, \f(CW\*(C`auto_threshold\*(C'\fR).
.IP "* get/put/update history" 4
.IX Item "get/put/update history"
Get or replace the entire history attribute (\f(CW\*(C`get_history\*(C'\fR,
\&\f(CW\*(C`put_history\*(C'\fR), or update it with a record of the current execution
(\f(CW\*(C`update_history\*(C'\fR).
.IP "* volume geometry" 4
.IX Item "volume geometry"
Query or compute volume sampling parameters and geometrical statistics
(\f(CW\*(C`volume_cog\*(C'\fR, \f(CW\*(C`volume_params\*(C'\fR, \f(CW\*(C`get_dimension_order\*(C'\fR).
.IP "* generate argument lists" 4
.IX Item "generate argument lists"
Generate argument lists for \f(CW\*(C`mincresample\*(C'\fR or \f(CW\*(C`mincreshape\*(C'\fR based on
desired sampling parameters for a volume (\f(CW\*(C`compute_resample_args\*(C'\fR,
\&\f(CW\*(C`compute_reshape_args\*(C'\fR).
.SH "EXPORTS"
.IX Header "EXPORTS"
By default, \fIMNI::MincUtilities\fR exports no symbols.  You can import in
the usual one-name-at-a-time way like this:
.PP
.Vb 1
\&   use MNI::MincUtilities qw(volume_min volume_params);
.Ve
.PP
which works fine if you're only using a few routines.  This quickly gets
cumbersome in large programs that use lots of routines, though, so the
module provides a couple of \*(L"export tags\*(R" to let you specify subroutines
by group.  The tags correspond to the groups of subroutines described
above; they are:
.ie n .IP """range""" 4
.el .IP "\f(CWrange\fR" 4
.IX Item "range"
.PD 0
.ie n .IP """threshold""" 4
.el .IP "\f(CWthreshold\fR" 4
.IX Item "threshold"
.ie n .IP """history""" 4
.el .IP "\f(CWhistory\fR" 4
.IX Item "history"
.ie n .IP """geometry""" 4
.el .IP "\f(CWgeometry\fR" 4
.IX Item "geometry"
.ie n .IP """args""" 4
.el .IP "\f(CWargs\fR" 4
.IX Item "args"
.PD
.PP
For example, to import the names of all the volume range functions:
.PP
.Vb 1
\&   use MNI::MincUtilities qw(:range);
.Ve
.PP
Finally, an \f(CW\*(C`all\*(C'\fR tag is provided to import all exportable symbols.
.SH "EXECUTION CONTROL"
.IX Header "EXECUTION CONTROL"
In order to cooperate better with other programs and modules,
\&\fIMNI::MincUtilities\fR makes an effort to respect the global \f(CW$Execute\fR
variable, and not to actually do much of anything if it is false.  If you
use \fIMNI::Startup\fR before \fIMNI::MincUtilities\fR, you shouldn't have any
problems: \fIMNI::Startup\fR will set its \f(CW$Execute\fR global to true, and
export it into your main program.  Then, when \fIMNI::MincUtilities\fR is
compiled, \f(CW$main::Execute\fR will already be available for it to use.  In
fact, the routines in \fIMNI::MincUtilities\fR will always use
\&\f(CW$main::Execute\fR, so you can change it at will (or the caller of your
program can change it with the \f(CW\*(C`\-execute\*(C'\fR command-line option), and
\&\fIMNI::MincUtilities\fR will either execute commands or not, depending on
\&\f(CW$main::Execute\fR.
.PP
However, if you choose not to \f(CW\*(C`use MNI::Startup\*(C'\fR, you'll have to define
\&\f(CW$main::Execute\fR before compiling \fIMNI::MincUtilities\fR, like this:
.PP
.Vb 2
\&   BEGIN { $Execute = 1; }
\&   use MNI::MincUtilities;
.Ve
.PP
If you don't have the creation of \f(CW$Execute\fR in a \f(CW\*(C`BEGIN\*(C'\fR block before
you \f(CW\*(C`use MNI::MincUtilities\*(C'\fR, then a warning will be printed and
\&\f(CW$main::Execute\fR will be defined for you (and set to 1).
.PP
The point of all this, in case you were wondering, is to allow your
program to operate in a \*(L"dry run\*(R" mode that runs no external programs
and depends on no temporary (or other) files.  This is very useful for a
\&\*(L"sanity check\*(R" pass, to make sure that a complicated program will do
just what you expect it to do without strange failures, rather than
running for several hours and then failing.  (Of course, it doesn't
protect you from everything\-\-\-just from silly logic errors that you
catch by reading any information echoed by the program, or from mistakes
in your Perl code that would crash the script.)  The routines in
\&\fIMNI::MincUtilities\fR not only avoid executing programs or depending on
the existence of files, they also return dummy values that you can
safely use in any further computations without fear of \*(L"uninitialized
value\*(R" warnings.  Generally, any numeric values (such as thresholds,
coordinates, and most sampling parameters) are returned as zero when
\&\f(CW$main::Execute\fR is false.  The exceptions are direction cosines, the
dimension list (both returned by \f(CW\*(C`volume_params\*(C'\fR), and
order/permutation vectors (returned by \f(CW\*(C`get_dimension_order\*(C'\fR).  These
are all returned in a \*(L"canonical form\*(R", namely (1,0,0,0,1,0,0,0,1) for
the direction cosines, (\f(CW\*(C`xspace\*(C'\fR, \f(CW\*(C`yspace\*(C'\fR, \f(CW\*(C`zspace\*(C'\fR) for the
dimension list, and (0,1,2) for order and permutation vectors.  (See
\&\f(CW\*(C`volume_params\*(C'\fR and \f(CW\*(C`get_dimension_order\*(C'\fR for more information on this
arcana.)
.SH "SUBROUTINES"
.IX Header "SUBROUTINES"
.Sh "Volume range"
.IX Subsection "Volume range"
.IP "volume_min (\s-1VOLUME\s0)" 4
.IX Item "volume_min (VOLUME)"
Gets the alleged volume minimum (from the \f(CW\*(C`image\-min\*(C'\fR variable).  This
may not be reliable, depending on the software that wrote \s-1VOLUME\s0.
.IP "volume_min (\s-1VOLUME\s0)" 4
.IX Item "volume_min (VOLUME)"
Gets the alleged volume maximum (from the \f(CW\*(C`image\-max\*(C'\fR variable).  This
may not be reliable, depending on the software that wrote \s-1VOLUME\s0.
.IP "volume_minmax (\s-1VOLUME\s0)" 4
.IX Item "volume_minmax (VOLUME)"
Calls \f(CW\*(C`volume_min\*(C'\fR and \f(CW\*(C`volume_max\*(C'\fR and returns their results (in that
order) as a two element list.  Again, this is of dubious reliability.
.Sh "Compute thresholds"
.IX Subsection "Compute thresholds"
.IP "percent_threshold (\s-1MIN\s0, \s-1MAX\s0, \s-1PERCENT\s0)" 4
.IX Item "percent_threshold (MIN, MAX, PERCENT)"
Computes the value that is \s-1PERCENT\s0 of the way between \s-1MIN\s0 and \s-1MAX\s0.  \s-1PERCENT\s0
should be a fraction in the range 0..1; \s-1MIN\s0 and \s-1MAX\s0 can be any numbers you
like, but they will most likely be the minimum and maximum real-world
values from some \s-1MINC\s0 file.  (This function doesn't actually do anything
with any \s-1MINC\s0 file, it just does arithmetic\-\-\-for that reason, it probably
belongs in \fIMNI::NumericUtilities\fR rather than \fIMNI::MincUtilities\fR.
Thus, it may be moved without warning at some point in the future\-\-\-be
warned!)
.IP "auto_threshold (\s-1VOLUME\s0)" 4
.IX Item "auto_threshold (VOLUME)"
Computes an automatic background threshold (using \f(CW\*(C`volume_stats\*(C'\fR
\&\f(CW\*(C`\-biModalT\*(C'\fR.  The threshold is returned as a real-world value.
.Sh "Get/put/update history"
.IX Subsection "Get/put/update history"
.IP "get_history (\s-1VOLUME\s0)" 4
.IX Item "get_history (VOLUME)"
Fetches the global \f(CW\*(C`history\*(C'\fR attribute from a \s-1MINC\s0 file, and splits it on
newline into a list of strings.  Since \f(CW\*(C`history\*(C'\fR attributes always end in
a newline, this results in an empty string at the end of the list;
\&\f(CW\*(C`get_history\*(C'\fR removes this empty string for you, and returns the resulting
list.
.IP "put_history (\s-1VOLUME\s0, \s-1HISTORY\s0)" 4
.IX Item "put_history (VOLUME, HISTORY)"
Joins \s-1HISTORY\s0 (a list of strings, not an array ref) with newlines,
appends a trailing newline, and puts the resulting string into the
global \f(CW\*(C`history\*(C'\fR attribute of the \s-1MINC\s0 file named by \s-1VOLUME\s0.  Using
\&\f(CW\*(C`get_history\*(C'\fR and \f(CW\*(C`put_history\*(C'\fR, it's quite easy to add your own line
to a \f(CW\*(C`history\*(C'\fR attribute:
.Sp
.Vb 3
\&   @history = get_history ($vol);
\&   push (@history, "this is my history line");
\&   put_history ($vol, @history);
.Ve
.Sp
or even:
.Sp
.Vb 1
\&   put_history ($vol, get_history ($vol), "this is my history line");
.Ve
.Sp
However, it's even easier if you use \f(CW\*(C`update_history\*(C'\fR (see below).
.IP "update_history (\s-1VOLUME\s0 [, \s-1REPLACE\s0 [, \s-1HISTORY\s0]])" 4
.IX Item "update_history (VOLUME [, REPLACE [, HISTORY]])"
Fetches, updates, and replaces the \f(CW\*(C`history\*(C'\fR global attribute from the
\&\s-1MINC\s0 file named by \s-1VOLUME\s0.
.Sp
\&\s-1REPLACE\s0 is an integer that tells how many entries to lop off the end of
the history list before appending a new entry.  This is useful if your
program runs a known number of external utilities, each of which
contributes one line to the history, in producing its output file.  You
could use \s-1REPLACE\s0 to drop the lines contributed by those external
utilities, so that running your program results in just one line being
added.  For example:
.Sp
.Vb 2
\&   Spawn (['mincresample', $invol, $tempvol, @resample_args]);
\&   Spawn (['mincreshape', $tempvol, $outvol, @reshape_args]);
.Ve
.Sp
.Vb 1
\&   update_history ($outvol, 2);
.Ve
.Sp
would result in one history line being added to \f(CW$tempvol\fR, and another to
\&\f(CW$outvol\fR.  Thus, we ask \f(CW\*(C`update_history\*(C'\fR to remove both of these lines
from \f(CW$outvol\fR, and replace them with the history line for your program.
If \s-1REPLACE\s0 is not supplied, it defaults to zero, meaning not to remove any
previous history lines.
.Sp
\&\s-1HISTORY\s0, if supplied, should be a string that is appended directly to the
history list\-\-\-thus, you can completely cook up a history line.  If \s-1HISTORY\s0
is not supplied (or undefined, or an empty string), then \f(CW\*(C`update_history\*(C'\fR
will create a history line for you.  This line will contain an exhaustive
summary of your program's execution environment, including the name of the
user running the program, the host, the current working directory at
program startup (from \f(CW$MNI::Startup::StartDir\fR), the date and time at
program startup (from \f(CW$^T\fR), the program name (\f(CW$0\fR) and its complete
argument list (\f(CW@ARGV\fR).  (This is yet another good reason why you
shouldn't clobber \f(CW$0\fR and \f(CW@ARGV\fR; the \fIMNI::Startup\fR and
\&\fIGetopt::Tabular\fR modules together make it easy to avoid this no\-no.)
.Sh "Volume geometry"
.IX Subsection "Volume geometry"
.IP "volume_cog (\s-1VOLUME\s0)" 4
.IX Item "volume_cog (VOLUME)"
Computes the \*(L"centre of gravity\*(R" of a volume using \f(CW\*(C`volume_cog\*(C'\fR.  This is
returned as a three-element array (x,y,z).
.IP "volume_params (\s-1VOLUME\s0, \s-1START\s0, \s-1STEP\s0, \s-1LENGTH\s0, \s-1DIRCOS\s0, \s-1DIMS\s0)" 4
.IX Item "volume_params (VOLUME, START, STEP, LENGTH, DIRCOS, DIMS)"
Gets all the sampling parameters for a \s-1MINC\s0 file and stuffs them into
arrays that you supply by reference.  All of the arguments except \s-1VOLUME\s0
should be array references or undefined; if an argument is undefined,
obviously you won't be able to get at the sampling parameters it
represents.
.Sp
The arrays referenced by \s-1START\s0, \s-1STEP\s0, and \s-1LENGTH\s0 will each be replaced
with three-element arrays containing the respective sampling parameter
in \fI(x,y,z)\fR order; \s-1DIRCOS\s0's array will become a nine-element array
with the direction cosines vectors for \fIx\fR, \fIy\fR, and \fIz\fR
respectively; and \s-1DIMS\s0' array will be replaced with a list of three
strings naming the three spatial dimensions in the file.
.Sp
The behaviour of \f(CW\*(C`volume_params\*(C'\fR on a file with less than three spatial
dimensions is undefined.
.IP "get_dimension_order (\s-1VOLUME\s0)" 4
.IX Item "get_dimension_order (VOLUME)"
Computes the dimension order and permutation for a \s-1MINC\s0 file.  These are
two vectors that are very useful when you need to go back and forth
between the canonical dimension ordering \fI(x,y,z)\fR and whatever order
the dimensions happen to be in in a particular \s-1MINC\s0 file.
.Sp
The dimension order vector is the easy one: order[\fIi\fR] tells you which
dimension is the \fIi\fR'th dimension of your volume.  For instance, a
coronal volume has dimensions \fI(y,z,x)\fR; its order vector is (1,2,0), a
simple transcription of \fI(y,z,x)\fR to numerical form.  (Put another way,
order[0]==1 means that dimension 0 of the file is canonical dimension 1,
or yspace.)
.Sp
The permutation vector is a little trickier to wrap your head around,
even though in a way it's just the \*(L"inverse\*(R" of the order vector.  In
short, perm[\fIi\fR] is where to find the \fIi\fR'th canonical dimension in
your file's dimension list.  Going with the coronal example again, the
permutation vector is (2,0,1): looking up canonical dimension 2 (zspace)
in perm[] gives 1, and indeed zspace is at slot 1 in the list of
dimensions (counting from zero, of course).
.Sp
The main reason that these two are so confusing is that they're usually
the same\-\-\-the reason I've used the coronal ordering as an example here
is that it's the only standard ordering where the order and permutation
vectors are different!  (Of the 6 possible orders for three dimensions,
only coronal \fI(y,z,x)\fR and the non-standard order \fI(z,x,y)\fR have
different order and permutation vectors.)  However, to be truly general,
you have to know when to use which one.
.Sp
In short: use the order vector when you have something in \fI(x,y,z)\fR
order and want it in volume order; use the permutation vector to go from
volume to \fI(x,y,z)\fR order.  This is particular easy in Perl using array
slices.  Say you have a list of parameters in \fI(x,y,z)\fR order (such as
the lists filled in by \f(CW\*(C`volume_params\*(C'\fR):
.Sp
.Vb 1
\&     @count = ($x_count, $y_count, $z_count);
.Ve
.Sp
that you want in volume order (say, for use with \f(CW\*(C`mincreshape\*(C'\fR).  Again
assuming a coronal volume, the order vector is (1,2,0), and so
.Sp
.Vb 3
\&     @count_v = @count[@order]
\&              = @count[1,2,0] 
\&              = ($y_count, $z_count, $x_count)
.Ve
.Sp
which of course is in coronal order.
.Sh "Generate argument lists"
.IX Subsection "Generate argument lists"
.IP "compute_resample_args (\s-1START\s0, \s-1EXTENT\s0, \s-1STEP\s0)" 4
.IX Item "compute_resample_args (START, EXTENT, STEP)"
Computes a list of arguments for \f(CW\*(C`mincresample\*(C'\fR based on the sampling
parameters implied by \s-1START\s0, \s-1EXTENT\s0, and \s-1STEP\s0 (all references to
three-element lists).  \s-1START\s0 and \s-1STEP\s0 should just contain the \f(CW\*(C`start\*(C'\fR and
\&\f(CW\*(C`step\*(C'\fR attributes for the three spatial dimensions, in \fI(x,y,z)\fR order.
\&\s-1EXTENT\s0 should describe the spatial extent of each dimension; it is
basically the same as the dimension length in a NetCDF file, except that it
is a real-world (not voxel) measurement and can be negative for dimensions
sampled in \*(L"reverse order\*(R" (with respect to the \s-1MINC\s0 standard).  In fact,
EXTENT[\fIi\fR] must be negative if STEP[\fIi\fR] is.
.Sp
\&\f(CW\*(C`compute_resample_args\*(C'\fR simply computes the dimension lengths (number
of samples) by dividing \s-1EXTENT\s0 by \s-1STEP\s0 and rounding up, and then puts
everything together with \f(CW\*(C`\-start\*(C'\fR, \f(CW\*(C`\-step\*(C'\fR, and \f(CW\*(C`\-nelements\*(C'\fR options.
A list containing all these options, suitable for popping into a
\&\f(CW\*(C`mincresample\*(C'\fR command list, is returned.
.IP "compute_reshape_args (\s-1ORDER\s0, \s-1OLDSTART\s0, \s-1OLDSTEP\s0, \s-1START\s0, \s-1EXTENT\s0, \s-1STEP\s0)" 4
.IX Item "compute_reshape_args (ORDER, OLDSTART, OLDSTEP, START, EXTENT, STEP)"
Computes the parameters necessary for \f(CW\*(C`mincreshape\*(C'\fR to give a volume a
new spatial extent as described by \s-1START\s0 and \s-1EXTENT\s0 (both references to
three-element arrays in \fI(x,y,z)\fR order).  If \s-1OLDSTART\s0 and \s-1START\s0 differ
by anything other than integral multiples of \s-1STEP\s0 (or \s-1OLDSTEP\s0), then
only approximate bounds will be computed.  The results are thrown
together as \f(CW\*(C`\-start\*(C'\fR and \f(CW\*(C`\-count\*(C'\fR options for \f(CW\*(C`mincreshape\*(C'\fR, and
returned as a list.
.Sp
\&\s-1ORDER\s0 should be the dimension order vector that will apply to the \fInew\fR
file; all the other vectors are in \fI(x,y,z)\fR order, so it's not
necessary to supply the order vector of the old file.  If you are
changing the dimension order, it's still your responsibility to put the
appropriate option (\f(CW\*(C`\-coronal\*(C'\fR, \f(CW\*(C`\-transverse\*(C'\fR, etc.) on the
\&\f(CW\*(C`mincreshape\*(C'\fR command line.
.SH "AUTHOR"
.IX Header "AUTHOR"
Greg Ward, <greg@bic.mni.mcgill.ca>.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 1997 by Gregory P. Ward, McConnell Brain Imaging Centre,
Montreal Neurological Institute, McGill University.
.PP
This file is part of the \s-1MNI\s0 Perl Library.  It is free software, and may be
distributed under the same terms as Perl itself.
